{
  "hash": "1068e9485aeeeef9b9702e209548ac72",
  "result": {
    "markdown": "---\ntitle: \"Tidy Evaluation Guide - Overview\"\nsubtitle: \"Data Masking\"\nauthor: \"Priyanka Gagneja\"\ndate: \"2023-05-10\"\ncategories: [news, code, analysis]\nimage: \"image.jpg\"\ncode-annotations: hover\ncss: styles.css\nformat:\n  revealjs:\n    incremental: true\n    theme: solarized\n---\n\n\n## Programming variables\n\n-   **Environment** variable - variables that live inside environments.\n\n-   **Data** variable - variables stored in data frames.\n\n## Data Masking\n\nIt is a feature that lets you *blend programming variables*.\n\nEasily to refer to data frame columns -\n\n-   as **columns** itself, or\n\n-   as **objects** defined in the current environment.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 100\nmtcars %>% \n  dplyr::summarise(mean(disp / x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  mean(disp/x)\n1     2.307219\n```\n:::\n:::\n\n\n## But!!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a dataframe\n(df <- data.frame(x = NA, y = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x y\n1 NA 2\n```\n:::\n\n```{.r .cell-code}\n# create a variable\n(x <- 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n\n```{.r .cell-code}\n# divide the column y by 100.\ndf %>% \n  dplyr::mutate(y = y / x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x  y\n1 NA NA\n```\n:::\n:::\n\n\n## But!!\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a dataframe               \n(df <- data.frame(x = NA, y = 2))       \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x y\n1 NA 2\n```\n:::\n\n```{.r .cell-code}\n# create a variable\n(x <- 100)                              \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n\n```{.r .cell-code}\n# divide the column y by 100.\ndf %>% \n  dplyr::mutate(y = y / x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x  y\n1 NA NA\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n::: callout-note\n## Data Variable\n:::\n\n::: callout-note\n## Environment Variable\n:::\n:::\n:::\n\n::: callout-caution\n## Collision\n\nA collision leads to this unexpected behavior\n:::\n\n## Collisions\n\nA collision occurs when there exists an object in the environment and a column in data frame have same name.\n\n-   Column - when you actually wanted to use the object.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- data.frame(x = NA, y = 2)\n    x <- 100\n    \n    df %>% dplyr::mutate(y = y / x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       x  y\n    1 NA NA\n    ```\n    :::\n    :::\n\n\n-   Object - when you actually wanted to use the column.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = \"right\")\nxx <- \"wrong\"\n\ndf %>% \n  dplyr::mutate(foo = toupper(xx))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x   foo\n1 right WRONG\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  dplyr::mutate(foo = toupper(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x   foo\n1 right RIGHT\n```\n:::\n:::\n\n:::\n:::\n\n## How to prevent collisions\n\n**BE EXPLICIT**\n\n\n::: {.cell}\n\n:::\n\n\n-   Use .data and .env pronouns\\\n.data refers to the dataframe in the latest state before the pipe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% dplyr::mutate(y = .data$y / .env$x)\n```\n:::\n\n\n-   Subsetting .data with env-variables\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar <- \"cyl\"\nmtcars %>% dplyr::summarise(mean = mean(.data[[var]]))\n```\n:::\n\n\n::: callout-note\n## .data pronoun can only be subsetted with env-variables, not data-variables.\n\n[[ behaves like an !!(injection operator)\n:::\n\n\n\n-   Injecting env-variables with !!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% dplyr::mutate(y = y / !!x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x    y\n1 1 0.02\n```\n:::\n:::\n\n\n## Questions\n\n::: callout-note\nTechnically, this is because [[ behaves like an injection operator when applied to .data. It is evaluated very early before the data mask is even created.\n:::\n\n\n::: callout-note\nInjection operators such as !! **modify a piece of code early on** by injecting objects or other expressions **before any data-masking logic comes into play**. If you inject the value of a variable, it becomes inlined in the expression. R no longer needs to look up any variable to find the value.\n:::\n\n\n\n## Tidy Selections\n\n-   Dialect of R that optimises column selection in tidyverse packages.\n\n-   No ambiguity due to its implementation.\n\n    -   Evaluation of expressions is **either scoped in the data mask only**, or *in the environment only*.\n\n-   Examples - dplyr::select() and tidyr::pivot_longer().\n\n- Tidy selections distinguish data-expressions and env-expressions:\n\ndata is a data-expression that refers to the data-variable.\n\nncol(data) is an env-expression that refers to the env-variable.\n\n## Names pattern with all_of()\n\n- `all_of()` is often used in functions as a programming pattern that connects column names to a data mask, similarly to the .data pronoun. \n\n::: {.cell}\n\n:::\n\n\n- `all_of()` is an env-expression that is evaluated outside of the data mask, so there is no possibility of collisions.\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}